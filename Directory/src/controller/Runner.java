package controller;

import model.*;
import view.*;

public class Runner {

	private static Almanac almanac = new Almanac();

	public static Almanac getAlmanac() {
		return almanac;
	}

	public static void main(String[] args) {
		genarateModels();
		genarateControllers();
		generateGUI();
	}

	private static void genarateModels() {
		almanac.setTests(generateTests());
		almanac.setThemes(generateThemes());
	}

	private static Theme[] generateThemes() {
		Theme them1 = new Theme("Введение в технологию Java",
				"В современном мире существует множество различных операционных систем (Windows, Mac OS, Unix-подобные). Программное обеспечение, написанное для одной системы, не будет работать на другой операционной системе. Это связано с различным устройством исполняемых файлов и функций операционных систем. Java позволяет решить проблему запуска одного приложения на различных ОС, предлагая пользователям не только язык разработки, но и целую платформу. "
						+ "Цели и задачи технологии Java Основной целю технологии Java является принцип – «Написанное один раз – работает везде» (англ. «Write once – run anywhere.» WORA). Идея состоит в том, что написав один раз код приложения, можно повторно его использовать на различных устройствах и операционных системах, без каких-либо дополнительных усилий. Немаловажной задачей Java является обеспечение высокой эффективности приложений, что достигается быстрым преобразованием байт-кода в язык машинных кодов. Большое внимание в Java уделяется безопасности. В платформе присутствует множество классов для шифрования и работе с сертификатами. Язык Java задумывался как «язык для домохозяек», т.е. он очень простой для понимания и изучения. Сравнение технологии Java с другими технологиями программирования (.Net Framework, C++ и др.) При разработке Java, за основу был взят язык С++, этим обусловлено множество совпадений в синтаксисе \r\n"
						+ "Март и семантике. За основу объектной модели взят подход из языка Smalltalk. Сравнение С++ и Java:\n ■ в Java отсутствует перегрузка операторов\n; ■ в Java отсутствует прямой доступ к памяти через указатель\n; ■ в Java отсутствуют деструкторы\n; ■ в Java отсутствует возможность процедурного программирования\n; ■ в Java статическая длина массивов и проверка индекса при доступе к элементу\n; ■ в Java значение переменных экземпляра (полей класса), в случае отсутствия инициализации, принимают значения по умолчанию (для целых и дробных типов это 0, для boolean – это false, для ссылочных типов – это null)\n; ■ в Java отсутствуют препроцессорные операции\n; ■ в Java отсутствуют файлы заголовки (header)\n; ■ в Java контроль за расходом памяти возложен на специальный механизм сборки мусора, в С++ за этим следит сам программист. Платформы Java и ее составные части Java платформа – это набор средств для разработки на языке Java, которые поставляются разработчику в виде единого готового решения. В платформу входят\n: ■ стандартные библиотеки\n; ■ средств компиляции\n; ■ средства выполнения кода\n;■ средства подготовки документации по коду\n; ■ примеры\n; ■ другие средства для разработки\n. Редакции платформ Java Java платформа поставляться в виде единого пакета разной редакции (комплектации). Для каждой редакции существует отдельная нумерация версий платформы.  ■ JSE или J2SE (Java Standart Edition) – это стандартная редакция платформы Java, используемая при разработке консольных приложений, в виде апплетов или stendelone приложений с графическим интерфейсом, приложений работающих с базами данных и сетью.  ■ JEE или J2EE (Java Enterprise Edition) – это редакция платформы, которая предназначена для разработки распределенных приложений уровня предприятия. Содержит в себе технологии Servlet, JSP, EJB. ■ JME (Java Micro Edition) – это редакция платформы, которая предназначена для разработки приложений под микрокомпьютеры (мобильные телефоны, планшеты и т.д.). В нее входят облегченные стандартные классы и классы для написания мидлетов (Midlets)\\n.  ■ Java FX – это платформа (2007 г.) для разработки приложений с графическим интерфейсом. Включена в  8 JSE, до этого была отдельной библиотекой. ");
		Theme them2 = new Theme("Базовые понятия технологии Java",
				"Виртуальная машина (JVM) – это спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java. Машина считается виртуальной, так как большую ее часть составляют различные программные компоненты. Существуют JVM реализованные различными производителями, но все они придерживаются единой спецификации. Реализация JVM это программное обеспечение, интерпретирующее инструкции байт-кода программы в команды операционной системы. Компилятор – это средство, которое преобразует исходный код в байт-код. Java компилятор написан на языке Java. Существуют компиляторы, которые преобразуют исходный код с других языков (Ada, JavaScript, Python, Ruby) в байт-код. Существуют так же языки, адаптированные для работы на виртуальной Java машине (Scala, Groovy). Байт код – это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной. Каждая инструкция кодируется одним байтом. Существует 205 инструкций, остальные (51) являются резервом. Байт-код создается в результате компиляции кода программы, находящейся в файлах с расширением java. Байт-код сохраняется в файлах с расширением class. Основным принципом технологии Java является тезис «Написанное один раз – работает везде.» (WORA). Благодаря особенностям платформы, программы, написанные на Java, гарантированно работают на всех операционных системах, для которых существуют реализации виртуальной Java машины (Платформенная независимость). Сборка мусора В некоторых языках программирования (например таких, как С++) контроль за использованием памяти возложен на плечи программиста, что усложняет процесс разработки и приводит к большому количеству ошибок и утечкам в памяти. В Java контроль за использованием памяти возложен на специальный механизм, который называется сборкой мусора (garbage collector). Наличие механизма автоматической сборки мусора (более не используемых данных) упрощает процесс разработки и уменьшает количество ошибок при работе с памятью.");
		Theme them3 = new Theme("Жизненный цикл, компиляции и исполнения  приложения Java",
				"Разработка приложений на Java начинается с написания исходного кода. Код хранится в файлах с расширением java. Исходный код преобразуется (компилируется) программой компилятор в байт-код (файлы, имеющие расширения class). Для выполнения программы, байт-код запускается на виртуальной машине, которая интерпретирует его в команды операционной системы, которая в свою очередь передает команды аппаратной части электронного устройства.");
		Theme them4 = new Theme("Инсталляция платформы Java",
				"Шаг 1. Найти и скачать установочный пакет можно по адресу: http://www.oracle.com/technetwork/java/javase/downloads/ index.html. Выберете версию JDK и операционную систему (обратите внимание на разрядность), на которую будет установлена платформа.\r\n"
						+ "10 \r\n" + "Урок № 1. Введение в язык программирования Java\r\n"
						+ "Шаг 2. Запустите установочный пакет. \r\n"
						+ "Шаг 3.  Если необходимо, смените путь для установки JDK. \r\n" + "11 \r\n"
						+ "1. Введение в технологию Java\r\n"
						+ "Шаг 4. Установка JRE начнется сразу после установки JDK.\r\n"
						+ "Процесс установки отображается в виде прогресса «Status» на экране окна. \r\n" + "12 \r\n"
						+ "Урок № 1. Введение в язык программирования Java\r\n"
						+ "Окончание установки. Есть возможность зарегистрировать установленную JDK на сайте «Oracle», нажав на кнопку «Product Registration Information». Но это не обязательный шаг.\r\n"
						+ "13 \r\n" + "1. Введение в технологию Java\r\n"
						+ "Начиная с версии JSE 1.7, в установочный пакет входит платформа JavaFX, и ее установка начнется сразу после установки JRE. \r\n"
						+ "14 \r\n" + "Урок № 1. Введение в язык программирования Java\r\n"
						+ "Шаг 5. После установки Java платформы, необходимо сконфигурировть операционную систему для работы с Java. Для Windows найдите «Компьютер» («Мой компьютер») и выберите его с помощью правой кнопки мыши – в появившемся меню выберите пункт «Свойства». В появившемся окне выберите пункт «Дополнительные параметры системы».\r\n"
						+ "15 \r\n" + "1. Введение в технологию Java\r\n"
						+ "В новом окне необходимо нажать кнопку «Переменные среды».\r\n" + "16 \r\n"
						+ "Урок № 1. Введение в язык программирования Java\r\n" + "Выберите кнопку «Создать».\r\n"
						+ "В поле «Имя переменной» внесите значение «Java_ HOME», в поле «Значение переменной» внесите путь, куда была установлена JDK и нажмите «ОК».\r\n"
						+ "17 \r\n" + "1. Введение в технологию Java\r\n"
						+ "Найдите и выберете в окне «Переменные среды», в поле «Системные переменные» пункт «Patch», и нажмите кнопку «Изменить». В поле «Значение переменной» добавьте точку с запятой и путь к директории, где установлены утилиты JDK (директория bin).\r\n"
						+ "ВНИМАНИЕ!!! Не очищайте и не удаляйте информацию из поля «Значения переменной». JRE (Java Runtime Environment) – среда выполнения для Java приложений. Минимальный набор необходимый запуска Java приложений. Содержит виртуальную машину и библиотеки Java классов. JDK (Java Development Kit) – это набор для Java разработчика, включающий в себя: ■ компилятор (javac); ■ стандартные библиотеки классов; ■ примеры кода; ■ документацию; ■ утилиты; ■ исполнительную систему (java). java – исполняемый файл (находящийся в ...\\Java\\jdk\\ bin), запускающий виртуальную машину и передающий \r\n"
						+ "18 \r\n" + "Урок № 1. Введение в язык программирования Java\r\n"
						+ "байт-код для интерпретации. Файлы с байт-кодом указываются в качестве параметров. Например: java.exe -d HelloWorld.class javaс – компилятор исходного кода в байт-код. Например: javac.exe HelloWorld.java. jar – утилита создания архива (java ARchive) ZIP формата, в котором упаковываются файлы с байт-кодом и ресурсы программы. Предназначен для объединения модулей программы в цельные логические единицы. Jar файл может быть исполняемым, если содержит файл манифеста. javadoc – утилита создания документации на основе исходного кода. appletviewer – утилита просмотра приложений типа апплет.");
		Theme them5 = new Theme("Пример написания первого приложения",
				"Почти во всех средах разработки программного кода на Java, сам процесс компиляции и запуска программы скрыт от пользователя набором различных конфигураций запуска. В результате этого сокрытия многие начинающие разработчики не знают, как скомпилировать или запустить свою программу без IDE, хотя такие знания могут пригодится при формировании различных скриптов сборки. Запустить первую программу без IDE можно в три простых шага.\r\n"
						+ "19 \r\n" + "1. Введение в технологию Java\r\n"
						+ "Шаг 1. Создайте в блокноте файл HelloWorld.java. Заполните файл кодом из листинга 1.1 и сохраните его.\r\n"
						+ "Листинг 1.1 /** * Моя первая программа  */ public class HelloWorld { /**  * Точка входа в программу  */ public static void main(String[] args) {  System.out.println(\"Hello world!\"); } } ВАЖНО!!! Имя файла и регистр букв в имени файла должен в точности совпадать с именем класса в программе (следующим за ключевым словом class). \r\n"
						+ "Шаг 2. Откройте утилиту командной строки. Введите «javaс HelloWorld.java» и нажмите на клавиатуре клавишу «Enter». В случае успешной компиляции появится новый файл, имеющий то же имя, но c расширением «class». Это файл с байт-кодом вашей программы. \r\n"
						+ "20 \r\n" + "Урок № 1. Введение в язык программирования Java\r\n"
						+ "Шаг 3. Введите в командную строку javaс HelloWorld.class и нажмите Enter. Программа выполнится, после ее выполнения в окне командной строки будет выведено сообщение: Hello world!\r\n"
						+ "21 \r\n" + "");
		Theme them6 = new Theme("Обзор существующих IDE",
				"Для упрощения и ускорения процесса разработки программ под Java, создано большое количество различных интегрированных сред разработки, далее IDE (Integrated Development Environment). Все IDE можно разделить на две основные категории, которые существенно влияют на выбор: ■ платные; ■ бесплатные. Так же немаловажными параметрами при выборе IDE является время, требуемое для первоначальной загрузки, время установки среды, объем занимаемой в ОЗУ и виртуальной памяти. Лидерами по частоте использования являются: NetBeans, Eclips, Intelej IDEA. Как правило, многие продуктовые компании диктуют программисту, какую IDE ему использовать на проекте, поэтому будет очень хорошо, если вы будете иметь представление и небольшой опыт в каждой из популярных IDE.\r\n"
						+ "22 \r\n" + "Урок № 1. Введение в язык программирования Java\r\n"
						+ "NetBeans – бесплатная свободная среда разработки с открытым исходным кодом. Поддерживает различные языки программирования и разметки. Поддержка большинства современных Java технологий. Присутствует интерфейс на русском языке и большое русскоязычное сообщество.\r\n"
						+ "Официальный сайт: https://netbeans.org/. \r\n" + "23 \r\n"
						+ "1. Введение в технологию Java\r\n"
						+ "IDE Eclipse – бесплатная свободная среда для разработки многомодульных и кроссплатформенных приложений. Имеет открытый исходный код. Развивается и поддерживается некоммерческой организацией «Eclipse Foundation». Изначально среда принадлежала IBM. Представляет собой многослойный конструктор состоящий из сервисной платформы «OSGI» и «SWT/JFace». Расширение функционала осуществляется с помощью плагинов (plugins), которых имеется большое количество.\r\n"
						+ "Официальный сайт: https://eclipse.org/.\r\n" + "24 \r\n"
						+ "Урок № 1. Введение в язык программирования Java\r\n"
						+ "«InteleJ IDEA» – условно-бесплатная интеллектуальная среда разработки. Разрабатывается компанией «Jet Brains». Отличительной особенностью является понимание контекста и большого количества поддерживаемых технологий и фреймворков прямо из коробки. Имеется бесплатная версия Community (отсутствует поддержка JEE технологий) и платная Ultimate (30-дневный пробный период). Официальный сайт: https://www.jetbrains.com/idea/.\r\n"
						+ "Codenvy – бесплатная среда разработки, не ребующая установки приложения на компьютер. Разработка ведется в браузере, после загрузки в него необходимого контента. \r\n"
						+ "Официальный сайт: https://codenvy.com/");
		Theme them7 = new Theme("ООП",
				"1. Введение в объектно-ориентированное программирование Основная парадигма объектно-ориентированного программирования – наличие трех основных понятий: ■ инкапсуляция; ■ наследование; ■ полиморфизм. Все эти свойства применимы к объектам, ведь ООП – это и есть способ организации программы путем группировки кода в виде объектов. Объекты описываются отдельными полями (свойствами) и поведением (методам). Инкапсуляция программных компонентов – скрытие прямого доступа извне. Благодаря инкапсуляции, можно ограничить нежелательный доступ к членам класса или защитить их от неправильного использования для тех частей программы, которые существуют вне объекта. Для скрытия компонентов класса используйте модификатор доступа private. Концепция наследования позволяет создавать новые классы на базе существующих. Такие классы могут расширять характеристики базового класса или переопределять существующие. Наследование помогает значительно сократить однотипный программный код. Подробнее о наследовании будет описано в следующих пунктах. Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого класса действий. Это значит, что объекты классов наследников можно рассматривать как объект \r\n"
						+ "4 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "класса родителя при определенных условиях, а именно, при работе с общими свойствами и методами, которые заложены в базовый интерфейс. Если упростить понимание понятия полиморфизма, необходимо его перевести: «одно имя, но много форм». Рассмотри пример, который демонстрирует возможности полиморфизма. У ряда классов, которые наследуют от класса Shape, есть метод draw() (как и у класса родителя). Каждый конкретный класс переопределяет этот метод для отображения фигуры со своими уникальными характеристиками. Полиморфизм позволяет сказать, что все указанные фигуры являются экземплярами класса Shape и вызвать у них метод draw() . При этом, в зависимости от того, какая реализация этого метода в конкретном классе, будет отображена та или иная фигура.\r\n"
						+ "5 \r\n" + "2. Понятие класса и объекта\r\n"
						+ "2. Понятие класса и объекта Класс и объект – это два ключевых понятия в ООП. С помощью класса описывается некоторая сущность. Для описания любого предмета достаточно указать его характеристики (размер, цвет, скорость и т.п.) и поведение (движение, расчеты, визулизация и т.д.). Объектом же является экземпляр этого класса (конкретный представитель), который имеет свои уникальные значения заданных в классе характеристик. Пример: При разработке гоночной игры, используется класс Car. Машина имеет конкретный набор характеристик: модель, цвет, скорость и т.д. В процессе игры пользователь меняет автомобили (объекты), увеличивая их скорость и другие характеристики. Получается, что при изменении объекта, модернизируются поля экземпляра класса, но его структура остается неизменной. Дополнительная информация ■ Все классы в Java наследуются от класса Object. ■ Доступ к полю или методу объекта осуществляется через . (оператор точка). ■ Если объект объявить, но не проинициализировать, тогда он будет равен null (пустая ссылка). Если обратиться к методам или полям такого объекта, произойдет ошибка.\r\n"
						+ "6 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "3. Конструкторы Конструктор предназначен для инициализации всех компонентов класса, при создании нового объекта этого класса. Имя конструктора всегда совпадает с именем класса, в котором он объявлен. Конструктор не имеет тип возвращаемого значения. Конструктор вызывается командой: new имя_класса(<аргументы>); Пример: MyObject obj = new MyObject(); Конструктором по умолчанию называется конструктор без параметров, который неявно определен в каждом классе. Для переопределения логики конструктора по умолчанию, опишите в классе конструктор с пустыми скобками. Пример: public class Main { public static void main(String[] args) { A a = new A(); } } class A { A(){ System.out.println(\"Default constructor\"); } } Как видно из примера, при создании объекта вызовется конструктор класса А и произойдет вывод сообщения в консоль.\r\n"
						+ "7 \r\n" + "4. Поля и методы. Ключевое слово this\r\n"
						+ "4. Поля и методы. Ключевое слово this Поля класса могут быть как примитивного типа, так и объектами другого класса. Для определения полей констант, используйте ключевое слово final. По соглашению имен, константы в Java необходимо записывать заглавными буквами, каждое отдельное слово пишется через нижнее подчеркивание (пример: CONSTANT_FIELD). Следующий участок кода вызовет ошибку, т.к. нельзя изменять значение константы: public class Main { private static final int DEFAULT_INT = 1; public static void main(String[] args) { DEFAULT_INT = 5; } } При определении констант в полях класса, принято добавлять ключевое слово static, т.к. значения этого поля изменить невозможно, а если этого не делать, каждый отдельный экземпляр класса будет хранить в памяти отдельную версию этой константы. Поля, как и методы, могут быть статическими. Для этого, используйте ключевое слово static. Статические поля, которые объявлены в классе, являются общими для всех объектов этого класса, поэтому, при изменении этого поля в объекте A, оно изменится и в объекте B.\r\n"
						+ "8 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "Рассмотрим пример: public class Main { public static void main(String[] args) { System.out.println(A.staticField); A a = new A(); A b = new A(); System.out.println(a.staticField); a.staticField = 5; System.out.println(b.staticField); } } class A { public static int staticField = 1; }\r\n"
						+ "Отсюда следует, что лучше обращаться к статическому члену через имя класса, а не имя объекта. Может потребоваться, чтобы метод ссылался на вызвавший его объект. Для этого Java определено ключевое слово this. Оно может использоваться внутри любого метода для ссылки на текущий объект. Также, в Java существуют понятия getter и setter. Эти методы, имя которых начинается с приставки get и set соответственно, предназначены для получения и записи значений в переменную. Применив инкапсуляцию, мы можем скрыть переменную, но предоставить пользователю возможность получить это значение. В языке Java принято определять get и set методы для полей моделей или главных полей любого класса, а само поле делать private.\r\n"
						+ "9 \r\n" + "4. Поля и методы. Ключевое слово this\r\n"
						+ "Рассмотрим пример: public class Main { public static void main(String[] args) { File file = new File(); file.setName(\"My file\"); file.setData(String.valueOf(new Random().            nextInt())); File fileCopy = file.copy(); System.out.println(\"New file name: \" + fileCopy.            getName()); System.out.println(\"New file data: \" + fileCopy.            getData()); } } class File { private String name; private String data; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getData() { return data; } public void setData(String data) { this.data = data; } public File copy() {\r\n"
						+ "10 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "File file = new File(); file.data = this.data; file.name = this.name + \" (copy)\"; return file;\r\n"
						+ "}\r\n" + "}\r\n" + "11 \r\n" + "5. Перегрузка методов и конструкторов\r\n"
						+ "5. Перегрузка методов и конструкторов Перегрузить метод (overload) – это значит определить несколько одинаковых методов с разным набором параметров. Например: class Math { public int sum(int a, int b) { return a + b; } public int sum(int a, int b, int c) { return a + b + c; } } В примере показаны два метода, которые вычисляют сумму числовых аргументов. Тип возвращаемого значения и имена методов одинаковые, но набор аргументов отличается. При вызове метода sum, в зависимости от типов и количества переданных аргументов, будет вызвана та или иная реализация метода sum. Необходимо обратить внимание на то, что при перегрузке методов имена аргументов не имеют значения, роль играет только тип и количество параметров. Ошибка при перегрузке: public int sum(int a, int b) { return a + b; } public int sum(int x, int y) { return a + b; }\r\n"
						+ "12 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "При перегрузке методов можно изменять тип, не меняя количество аргументов: public int sum(int a, int b) { return a + b; } public float sum(float x, float y) { return a + b; }\r\n"
						+ "При перегрузке конструкторов используются те же правила, что и при перегрузке методов. Если мы определили один конструктор с параметрами, конструктор по умолчанию работать не будет и даст ошибку; для того чтобы, при наличии других версий конструкторов, конструктор по умолчанию работал, его необходимо явно объявить (можно оставить тело пустым или определить значения по умолчанию): public class Main { public static void main(String[] args) { Math math1 = new Math(); math1.x = 5; math1.y = 10; System.out.println(\"Max from: \" + math1.x + \" \" + math1.y + \" = \" + math1.max()); Math math2 = new Math(2, 3); System.out.println(\"Min from: \" + math2.x + \" \" + math2.y + \" = \" + math2.min()); System.out. println(\"Sum: \" + math2.x + \" \" + math2.y + \" = \" + math2.sum()); } }\r\n"
						+ "13 \r\n" + "5. Перегрузка методов и конструкторов\r\n"
						+ "class Math { int x, y; public Math() { this.x = 0; this.y = 0; } public Math(int x, int y) { this.x = x; this.y = y; } public int sum() { return x + y; } public int min() { return x <= y ? x : y; } public int max() { return x >= y ? x : y; } }\r\n"
						+ "14 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "6. Наследование Благодаря наследованию, класс наследник получает доступ к полям и методам базового класса (класса родителя). Наследовать можно классы, а можно интерфейсы (рассмотрим позже). Для того чтобы класс B мог наследовать от класса A, при объявлении класса B, следует указать ключевое слово extends и имя базового класса (А). Пример: public class Main { public static void main(String[] args) { A a = new A(); B b = new B(); a.sum(); b.sum(); } } class A { int x = 5, y = 5; public void sum() { System.out.println(x + y); } } class B extends A { } Как видно из примера, хотя класс B пустой, но благодаря наследованию, он получил доступ к полям x,y и методу sum().\r\n"
						+ "15 \r\n" + "6. Наследование\r\n"
						+ "Обычно, классы наследники либо дополняют базовый класс, либо переопределяют методы базового класса. Если дополнение – это простое добавление новых полей и методов, то процесс переопределения необходимо рассмотреть подробней. Переопределить метод (override) – это значит обеспечить специфическую реализацию метода, отличающуюся от реализации одноименного метода базового класса. Рассмотрим пример: public class Main { public static void main(String[] args) { Square square = new Square(4); Rectangle rectangle = new Rectangle(3, 5); System.out.println(\"Square perimeter: \" + square.                    getPerimeter()); System.out.println(\"Square area: \" + square.                    getArea()); System.out.println(\"Rectangle perimeter: \" +                     rectangle.getPerimeter()); System.out.println(\"Rectangle area: \" + rectangle.                    getArea()); } } class Square { int width; public Square(int width) { this.width = width; }\r\n"
						+ "16 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "public int getPerimeter() { return 4 * width; } public int getArea() { return width * width; }\r\n"
						+ "} class Rectangle extends Square { int height; public Rectangle(int width, int height) { super(width); this.height = height; } @Override public int getPerimeter() { return 2 * (height + width); } @Override public int getArea() { return width * height; } } Класс квадрат имеет поле width и методы для расчета периметра и площади квадрата. От этого класса наследуется класс прямоугольник. В нем добавлено поле height и предопределены методы расчета периметра и площади (т.к. расчетные формулы квадрата и прямоугольника отличаются). Аннотация @Override указывает, что метод был предопределен. \r\n"
						+ "17 \r\n" + "6. Наследование\r\n"
						+ "Обратите внимание на выделенную строку в конструкторе класса Rectangle. Ключевое слово super обеспечивает доступ к суперклассу, т.е. можно использовать реализацию методов базового класса внутри методов класса наследника. Если использовать запись super(<аргументы>), то это обеспечивает доступ к конструктору суперкласса. Вызов конструктора суперкласса обязательно должен происходить в конструкторе класса наследника. Следующая форма ключевого слова super – это доступ к члену суперкласса, например: super.x или super.x(); Для проверки, какому классу принадлежит объект (с учетом наследования) используйте оператор instanceof. Пример: if(object instanceof Square){ System.out.println(\"Object type is Square\"); } else if(object instanceof Rectangle){ System.out.println(\"Object type is Rectangle\"); } В языке Java существует возможность создавать базовые классы, которые не полностью реализованы, а требуют дополнительной реализации в классах наследниках. Такие классы называются абстрактными. Т.к. абстрактный класс не реализован до конца, то создавать экземпляры такого класса нельзя. Для определения абстрактного класса используйте ключевое слово abstract: abstract class A { }\r\n"
						+ "18 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "Методы абстрактного класса могут иметь реализацию (как в обычных класса), но также могут быть абстрактными, такие методы должен обязательно реализовать класс наследник. Для определения абстрактного метода используйте аналогичное ключевое слово abstract: public abstract void someMethod();\r\n"
						+ "19 \r\n" + "7. Понятие интерфейса\r\n"
						+ "7. Понятие интерфейса Интерфейс определяет как элементы будут взаимодействовать между собой. Все поля, которые объявлены в интерфейсе, автоматически являются static final (статическими константами). Все члены класса, как и методы, неявно объявляются public. Интерфейс можно сравнить с полностью абстрактным классом. Для создания интерфейса используйте ключевое слово interface. В языке Java присутствует множественное наследование интерфейсов, в отличие от классов (может быть только один класс родитель). Для наследования от интерфейса используйте ключевое слово implements. Если вы наследуете несколько интерфейсов, тогда укажите их через запятую. Любой класс одновременно может наследоваться от класса и от интерфейсов. Рассмотрим пример работы с интерфейсом. Изменим код программы вычисления периметра и площади фигур: public class Main { public static void main(String[] args) { Square square = new Square(4); Rectangle rectangle = new Rectangle(3, 5); System.out.println(\"Square perimeter: \" + square.                    getPerimeter()); System.out.println(\"Square area: \" + square.                    getArea()); System.out.println(\"Rectangle perimeter: \" +                     rectangle.getPerimeter()); System.out.println(\"Rectangle area: \" + rectangle.                    getArea()); } }\r\n"
						+ "20 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "interface Shape { int getPerimeter(); int getArea(); } class Square implements Shape { int width; public Square(int width) { this.width = width; } @Override public int getPerimeter() { return 4 * width; } @Override public int getArea() { return width * width; } } class Rectangle implements Shape { int width; int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } @Override public int getPerimeter() { return 2 * (height + width); } @Override public int getArea() { return width * height; } }\r\n"
						+ "21 \r\n" + "7. Понятие интерфейса\r\n"
						+ "Если класс Rectangle унаследовать от Square, он не будет обязательно нуждаться реализации методов интерфейса Shape, т.к. они уже определены в классе Square. Если вы хотите чтобы класс обязательно определял собственную реализацию тех или иных методов, унаследуйте его от интерфейса или базового класса. Игнорирования определения абстрактных методов вызовет ошибку.\r\n"
						+ "22 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "8. Вложенные и внутренние классы В языке Java существуют вложенные (nested) и внутренние (inner) классы. Все они обязательно определяются внутри другого класса. Область видимости такого класса ограничена внешним классом. Внутренние классы следует применять, потому что они повышают структурирование и улучшают читаемость кода. Также, это хороший способ группировки классов. Если классы помощники используются только в связке с другими классами, нет смысла определять их в отдельных файлах. В свою очередь, внутренние классы бывают статическими (вложенными) и нестатическими (внутренними). Статические вложенные классы применяются тогда, когда не нужна связь между объектами внутреннего и внешнего классов. Для создания экземпляра такого класса не нужен объект внешнего класса и нельзя обращаться к нестатическим полям и методам внешнего класса. Создание объекта вложенного класса: OuterClass.NestedClass object = new OuterClass. NestedClass(); Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может ссылаться на них. Внутренние классы не могут существовать без экземпляра внешнего класса. Создание объекта внутреннего класса: OuterClass.InnerClass object = outerObject.new InnerClass();\r\n"
						+ "23 \r\n" + "9. Анонимные классы\r\n"
						+ "9. Анонимные классы Анонимные классы – это безымянные классы, которые декларируются внутри методов основного класса и могут быть использованы только внутри этих методов. Главное требование к анонимному классу – он должен наследовать существующий класс или реализовывать существующий интерфейс. Рассмотрим работу с анонимными классами на примере: public class Main { public static void main(String[] args) { ArrayUtils uArray = new ArrayUtils(50); uArray.fill(3); uArray.print(); uArray.sum(new ArrayUtils.           OnCalculationListener() { @Override public void getResult(int sum) {    System.out.println(\"Array sum = \" + sum); } }); } } class ArrayUtils { private int[] array; public ArrayUtils(int count) { array = new int[count]; fill(1); } public void fill(int value) { Arrays.fill(array, value); }\r\n"
						+ "24 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "public void print() { for (int i = 0; i < array.length; i++)         System.out.print(array[i] + \" \"); System.out.println(); } public void sum (OnCalculationListener calculationListener) { int sum = 0; for (int i = 0; i < array.length; i++) sum += array[i]; if (calculationListener != null) calculationListener.getResult(sum); } interface OnCalculationListener { void getResult(int sum); } } Метод sum(OnCalculationListener calculationListener), класса ArrayUtils, принимает в качестве параметра объект интерфейса (или так называемого слушателя), интерфейс описывает метод getResult(int sum), т.е. метод sum предполагает, что клиент реализует метод интерфейса и определит в нем логику для работы с результатом суммирования элементов массива. В методе main(String[] args) мы вызвали метод uArray.sum и анонимно реализовали класс наследник интерфейса OnCalculationListener. В методе getResult(int sum) мы выводим результат суммирования в консоль. Возникает вопросы, мы ведь могли определить у метода sum(OnCalculationListener calculationListener) \r\n"
						+ "25 \r\n" + "9. Анонимные классы\r\n"
						+ "возвращаемое значение и вернуть сумму при вызове этого метода. Минус такого подхода в том, что он работает последовательно – пока идут вычисления, клиентская программа будет ожидать результат. Если элементов массива слишком много, тогда бы мы реализовали отдельный поток, в котором происходили вычисления, а слушатель асинхронно принимал результат. Также, возвращаемое значение позволяет вернуть только один результат, а так возможно определить в интерфейсе несколько методов, которые, в зависимости от входных данных, будут обрабатываться клиентом.\r\n"
						+ "26 \r\n" + "Урок № 7. Объектно-ориентированное программирование \r\n"
						+ "10. Шаблоны (Generics) Благодаря шаблонам в языке Java есть возможность создавать классы, которые будут приспособлены под работу с разными типами. Эти классы называют шаблонными или параметризованными. Для создания такого класса, необходимо определить в угловых скобках формальный тип и указать его у полей класса. Также, формальный тип можно указывать как тип возвращаемого значения или тип аргументов в методах такого класса. Вместо формального параметра, если от него не зависят другие аргументы и возвращаемое значение, есть возможность указывать неизвестный параметр <?> или неизвестный параметр ограниченного типа <? extends A> (т.е. все классы наследники класса A). Рассмотрим пример работы с шаблонными клас- сами: public class Main { public static void main(String[] args) { VirtualCollection<String> collection =                new VirtualCollection<String>(); collection.add(\"Привет\"); collection.add(\"Шаг\"); collection.add(\"и\"); collection.add(\"весь\"); collection.add(\"Мир!\"); collection.print(); System.out.print(\"Второй элемент: \" +                   collection.get(1)); } }\r\n"
						+ "27 \r\n" + "10. Шаблоны (Generics)\r\n"
						+ "class VirtualCollection<T extends Object> { private T[] array; public VirtualCollection() { array = (T[]) new Object[0]; } public void print() { for (T anArray : array) System.out.print(anArray + \" \"); System.out.println(); } public void add(T newValue) { T[] newArray = Arrays.copyOf(array, array.length                              + 1); this.array = newArray; array[array.length – 1] = newValue; } public T get(int position) { if (position >= 0 && position < array.length) return array[position]; else return null; } } Мы создали примитивную коллекцию элементов, которая, в отличие от массива, умеет менять свою длину (метод add(T)). При создании объекта шаблонного класса мы обязательно должны указать в угловых скобках конкретный тип данных. Мы выбрали строковый тип данных, занесли несколько элементов и отобразили результат на экран.");
		Theme[] themes = { them1, them2, them3, them4, them5, them6, them7 };
		return themes;
	}

	private static Test[] generateTests() {
		Question quest1Theme1 = new Question("Виртуальная машина (JVM) – это: ",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "\r\n" + "Б) средство, которое преобразует исходный код в байт-код;"
						+ " В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;",
				"A", 1);
		Question quest2Theme1 = new Question("Компилятор – это:",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "\r\n" + "Б) средство, которое преобразует исходный код в байт-код; "
						+ "В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;\r\n"
						+ "\r\n"
						+ "Г) набор средств для разработки на языке Java, которые поставляются разработчику в виде единого готового решения.",
				"Б", 1);
		Question quest3Theme1 = new Question("Байт код – это:",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "\r\n" + "Б) средство, которое преобразует исходный код в байт-код;"
						+ "В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;\r\n "
						+ "\r\n"
						+ "Г) набор средств для разработки на языке Java, которые поставляются разработчику в виде единого готового решения.",
				"В", 1);
		Question quest4Theme1 = new Question("Java платформа – это: ",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "\r\n" + "Б) средство, которое преобразует исходный код в байт-код;"
						+ "В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;\r\n "
						+ "\r\n"
						+ "Г) набор средств для разработки на языке Java, которые поставляются разработчику в виде единого готового решения.",
				"Г", 1);
		Question quest5Theme1 = new Question("В платформу входят:",
				"А) стандартные библиотеки;\r\n" + "\r\n" + "Б) средств компиляции;\r\n" + "\r\n"
						+ "В) средства выполнения кода;\r\n" + "\r\n"
						+ "Г) средства подготовки документации по коду;\r\n" + "\r\n" + "Д) примеры;\r\n" + "\r\n"
						+ "Е) другие средства для разработки.\r\n" + "\r\n" + "Ё) все выше перечисленные.",
				"Ё", 1);
		Question quest6Theme1 = new Question("Исходный код – это",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "Б) средство, которое преобразует исходный код в байт-код;\r\n" + "\r\n"
						+ "В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;\r\n"
						+ "\r\n" + "Г) набор команд и операций предназначенных для выполнение вычислительных операций.",
				"Г", 1);
		Question quest7Theme1 = new Question("Реализация JVM – это:",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "Б) средство, которое преобразует исходный код в байт-код;\r\n" + "\r\n"
						+ "В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;\r\n"
						+ "\r\n"
						+ "Г) набор команд и операций предназначенных для выполнение вычислительных операций.\r\n"
						+ "\r\n"
						+ "Д) основная часть исполняющей системы Java, также называемой Java Runtime Environment(JRE);",
				"Д", 1);
		Question quest8Theme1 = new Question("Java Development Kit (JDK) – это:",
				"А) спецификация, описывающая абстрактную машину, в которой могут выполняться приложения на Java;\r\n"
						+ "\r\n"
						+ "Б) бесплатно распространяемый компанией Oracle комплект для разработки приложений на языке Java;\r\n"
						+ "\r\n"
						+ "В) это набор инструкций на промежуточном языке, предназначенный для выполнения виртуальной машинной;\r\n"
						+ "\r\n"
						+ "Г) набор команд и операций предназначенных для выполнение вычислительных операций.\r\n"
						+ "\r\n"
						+ "Д) основная часть исполняющей системы Java, также называемой Java Runtime Environment(JRE);",
				"Б", 1);

		Question quest1Theme2 = new Question("Примитивные типы данных – это:",
				"А) тип который в качестве значения содержит ссылку на объект;\r\n" + "\r\n"
						+ "Б) типы данных которые могут хранить в себе только целые числа (без дробной части), из диапазона заданного размерностью типа;\r\n"
						+ "\r\n" + "В) типы данных предназначены для хранения значений дроби;\r\n" + "\r\n"
						+ "Г) типы данных присутствующие в синтаксисе языка.",
				"Г", 1);
		Question quest2Theme2 = new Question("Ссылочный тип (объектный тип) – это:",
				"А) тип который в качестве значения содержит ссылку на объект;\r\n" + "\r\n"
						+ "Б) типы данных которые могут хранить в себе только целые числа (без дробной части), из диапазона заданного размерностью типа;\r\n"
						+ "\r\n" + "В) типы данных предназначены для хранения значений дроби;\r\n" + "\r\n"
						+ "Г) типы данных присутствующие в синтаксисе языка.",
				"А", 1);
		Question quest3Theme2 = new Question("Примитивные типы данных делятся на:",
				"А) целочисленный тип;\r\n" + "\r\n" + "Б) строчный тип;\r\n" + "\r\n" + "В) символьный тип;\r\n"
						+ "\r\n" + "Г) странный тип;\r\n" + "\r\n" + "Д) дробные тип;\r\n" + "\r\n"
						+ "Е) логический тип;",
				"А" + "В" + "Д" + "Е", 4);
		Question quest4Theme2 = new Question("К целочисленным типам относиться:",
				"А) byte;\r\n" + "\r\n" + "Б) char;\r\n" + "\r\n" + "В) int;\r\n" + "\r\n" + "Г) double;\r\n" + "\r\n"
						+ "Д) boolean;\r\n" + "\r\n" + "Е) float;\r\n" + "\r\n" + "Ё) long;\r\n" + "\r\n" + "Ж) short;",
				"А" + "В" + "Ё" + "Ж", 4);
		Question quest5Theme2 = new Question("К дробным типам относиться:",
				"А) целочисленный тип;\r\n" + "\r\n" + "Б) строчный тип;\r\n" + "\r\n" + "В) символьный тип;\r\n"
						+ "\r\n" + "Г) странный тип;\r\n" + "\r\n" + "Д) дробные тип;\r\n" + "\r\n"
						+ "Е) логический тип;",
				"Г" + "Е", 2);
		Question quest6Theme2 = new Question("К символьному типу относиться:",
				"А) целочисленный тип;\r\n" + "\r\n" + "Б) строчный тип;\r\n" + "\r\n" + "В) символьный тип;\r\n"
						+ "\r\n" + "Г) странный тип;\r\n" + "\r\n" + "Д) дробные тип;\r\n" + "\r\n"
						+ "Е) логический тип;",
				"Б", 1);
		Question quest7Theme2 = new Question("К логическому типу относиться:",
				"А) целочисленный тип;\r\n" + "\r\n" + "Б) строчный тип;\r\n" + "\r\n" + "В) символьный тип;\r\n"
						+ "\r\n" + "Г) странный тип;\r\n" + "\r\n" + "Д) дробные тип;\r\n" + "\r\n"
						+ "Е) логический тип;",
				"Д", 1);
		Question quest8Theme2 = new Question("Какая разрядность у byte:", "А) 8 бит (1 байт);\r\n" + "\r\n"
				+ "Б) 16 бит (2 байта);\r\n" + "\r\n" + "В) 32 бита (4 байта);\r\n" + "\r\n" + "Г) 64 бита (8 байт);",
				"А", 1);
		Question quest9Theme2 = new Question("Какая разрядность у shor:", "А) 8 бит (1 байт);\r\n" + "\r\n"
				+ "Б) 16 бит (2 байта);\r\n" + "\r\n" + "В) 32 бита (4 байта);\r\n" + "\r\n" + "Г) 64 бита (8 байт);",
				"Б", 1);
		Question quest10Theme2 = new Question("Какая разрядность у int:", "А) 8 бит (1 байт);\r\n" + "\r\n"
				+ "Б) 16 бит (2 байта);\r\n" + "\r\n" + "В) 32 бита (4 байта);\r\n" + "\r\n" + "Г) 64 бита (8 байт);",
				"В", 1);
		Question quest11Theme2 = new Question("Какая разрядность у long:", "А) 8 бит (1 байт);\r\n" + "\r\n"
				+ "Б) 16 бит (2 байта);\r\n" + "\r\n" + "В) 32 бита (4 байта);\r\n" + "\r\n" + "Г) 64 бита (8 байт);",
				"Г", 1);
		Question quest12Theme2 = new Question("Какая разрядность у float:",
				"А) 32 бита (4 байта);\r\n" + "\r\n" + "Б) 64 бита (8 байт);\r\n" + "\r\n" + "В) 16 бит (2 байта);",
				"А", 1);
		Question quest13Theme2 = new Question("Какая разрядность у double:",
				"А) 32 бита (4 байта);\r\n" + "\r\n" + "Б) 64 бита (8 байт);\r\n" + "\r\n" + "В) 16 бит (2 байта);",
				"Б", 1);
		Question quest14Theme2 = new Question("Какая разрядность у char:",
				"А) 32 бита (4 байта);\r\n" + "\r\n" + "Б) 64 бита (8 байт);\r\n" + "\r\n" + "В) 16 бит (2 байта);",
				"В", 1);
		Question quest15Theme2 = new Question("Какой диапазон значений у byte:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "А", 1);
		Question quest16Theme2 = new Question("Какой диапазон значений у short:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "Б", 1);
		Question quest17Theme2 = new Question("Какой диапазон значений у int:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "В", 1);
		Question quest18Theme2 = new Question("Какой диапазон значений у long:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "Г", 1);
		Question quest19Theme2 = new Question("Какой диапазон значений у float:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "Д", 1);
		Question quest20Theme2 = new Question("Какой диапазон значений у double:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "Е", 1);
		Question quest21Theme2 = new Question("Какой диапазон значений у char:", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "Ё", 1);
		Question quest22Theme2 = new Question("Какой диапазон значений у boolean::", "А) от –128 до 127;\r\n" + "\r\n"
				+ "Б) от –32 768 до 32 767;\r\n" + "\r\n" + "В) от –2 в 31 степени до 2 в степени 31;\r\n" + "\r\n"
				+ "Г) от –2 в 63 степени до 2в 63 степени;\r\n" + "\r\n" + "Д) от –3. 4е – 038.. до 3. 4е + 038;\r\n"
				+ "\r\n" + "Е) от –1. 7е – 308.. до 1. 7е + 308;\r\n" + "\r\n" + "Ё) от 0 до 65536;\r\n" + "\r\n"
				+ "Ж) true или false;", "Ж", 1);
		Question quest23Theme2 = new Question("Автоматическая упаковка – это:",
				"А) механизм неявного создания (без использования оператора new) объекта класса-обертки, соответствующего примитивного типа;\r\n"
						+ "\r\n"
						+ "Б) механизм неявного преобразования объекта типа-обертки в примитивный тип соответствующего типа;\r\n"
						+ "\r\n"
						+ "В) именованная область памяти, в которую может быть записано или перезаписано и откуда может быть прочитано значение определенного типа;\r\n"
						+ "\r\n"
						+ "Г) переменная, которая должна быть инициализирована в месте объявления (или в конструкторе класса) и не может изменять своего значения на протяжении видимости этой переменной в коде;",
				"А", 1);
		Question quest24Theme2 = new Question("Автоматическая распаковка – это:",
				"А) механизм неявного создания (без использования оператора new) объекта класса-обертки, соответствующего примитивного типа;\r\n"
						+ "\r\n"
						+ "Б) механизм неявного преобразования объекта типа-обертки в примитивный тип соответствующего типа;\r\n"
						+ "\r\n"
						+ "В) именованная область памяти, в которую может быть записано или перезаписано и откуда может быть прочитано значение определенного типа;\r\n"
						+ "\r\n"
						+ "Г) переменная, которая должна быть инициализирована в месте объявления (или в конструкторе класса) и не может изменять своего значения на протяжении видимости этой переменной в коде;",
				"Б", 1);
		Question quest25Theme2 = new Question("Переменная– это:",
				"А) механизм неявного создания (без использования оператора new) объекта класса-обертки, соответствующего примитивного типа;\r\n"
						+ "\r\n"
						+ "Б) механизм неявного преобразования объекта типа-обертки в примитивный тип соответствующего типа;\r\n"
						+ "\r\n"
						+ "В) именованная область памяти, в которую может быть записано или перезаписано и откуда может быть прочитано значение определенного типа;\r\n"
						+ "\r\n"
						+ "Г) переменная, которая должна быть инициализирована в месте объявления (или в конструкторе класса) и не может изменять своего значения на протяжении видимости этой переменной в коде;",
				"В", 1);
		Question quest26Theme2 = new Question("Константа– это:",
				"А) механизм неявного создания (без использования оператора new) объекта класса-обертки, соответствующего примитивного типа;\r\n"
						+ "\r\n"
						+ "Б) механизм неявного преобразования объекта типа-обертки в примитивный тип соответствующего типа;\r\n"
						+ "\r\n"
						+ "В) именованная область памяти, в которую может быть записано или перезаписано и откуда может быть прочитано значение определенного типа;\r\n"
						+ "\r\n"
						+ "Г) переменная, которая должна быть инициализирована в месте объявления (или в конструкторе класса) и не может изменять своего значения на протяжении видимости этой переменной в коде;",
				"Г", 1);

		Question quest1Theme3 = new Question(
				"Какие основные принципы содержит в себе классическая   парадигма объектно-ориентированного программирования?\r\n",
				"1.	Инкапсуляция\r\n" + "2.	Наследование\r\n" + "3.	Полиморфизм\r\n" + "4.	Агрегирование\r\n"
						+ "5.	Сокрытие\r\n" + "6.	Композиция\r\n" + "7.	Манипуляция\r\n" + "8.	Абстракция\r\n"
						+ "9.	Внедрение зависимости\r\n",
				"1" + "2" + "3" + "8", 4);
		Question quest2Theme3 = new Question(
				"Укажите какие ключевые слова могут быть использованы при объявлении переменных экземпляра (полей класса)?\r\n",
				"1.	private\r\n" + "2.	public\r\n" + "3.	static\r\n" + "4.	final\r\n" + "5.	protected\r\n"
						+ "6.	abstract\r\n",
				"1" + "2" + "3" + "4" + "5", 4);
		Question quest3Theme3 = new Question(
				"Укажите какие ключевые слова могут быть использованы перед объявлением (не вложенного) класса?",
				"1.	private\r\n" + "2.	public\r\n" + "3.	final\r\n" + "4.	protected\r\n" + "5.	abstract\r\n"
						+ "6.	static\r\n" + "7.	package-private\r\n",
				"2" + "3" + "5", 3);
		Question quest4Theme3 = new Question("Членами класса называют:",
				"1.	Все методы и поля класса\r\n" + "2.	Не статические методы и поля класса\r\n"
						+ "3.	Только методы класса\r\n" + "4.	Только не статические поля класса\r\n"
						+ "5.	Только статические методы и поля класса.",
				"1", 1);
		Question quest5Theme3 = new Question("Сеттеры (setters) это методы, которые",
				"1.	Добавляют данные в объект\r\n" + "2.	Удаляют данные из объекта\r\n"
						+ "3.	Изменяют атрибуты объекта\r\n" + "4.	Получают данные из объекта",
				"5", 1);
		Question quest6Theme3 = new Question("Какой из модификаторов доступа самый закрытый (жесткий)?",
				"1.	protected\r\n" + "2.	default\r\n" + "3.	private\r\n" + "4.	public", "3", 1);
		Question quest7Theme3 = new Question(
				"Укажите какие ключевые слова могу использоваться перед объявлением метода в классе?",
				"1.	private\r\n" + "2.	public\r\n" + "3.	protected\r\n" + "4.	final\r\n" + "5.	static\r\n"
						+ "6.	abstract\r\n" + "7.	native\r\n" + "8.	instanceof\r\n" + "9.	var\r\n"
						+ "10.	const\r\n" + "11.	strictfp",
				"1" + "2" + "3" + "4" + "5" + "6" + "7", 7);
		Question quest8Theme3 = new Question("Наследуются ли поля класса имеющие модификатор private?",
				"1.	Да\r\n" + "2.	Нет\r\n" + "3.	Только если они имеют геттеры", "3", 1);
		Question quest9Theme3 = new Question("Объекты каких типов можно создать без оператора new?",
				"1.	StringBuilder\r\n" + "2.	Object\r\n" + "3.	Integer\r\n" + "4.	массив\r\n" + "5.	String",
				"3" + "4" + "5", 3);
		Question quest10Theme3 = new Question("От какого класса неявно наследуются все классы в java?", "1.	Class\r\n"
				+ "2.	String\r\n" + "3.	Bog\r\n" + "4.	God\r\n" + "5.	Object\r\n" + "6.	Product", "5", 1);
		Question quest11Theme3 = new Question(
				"Какой модификатор доступа у метода в интерфейсе, если не указывать модификатор явно?",
				"1.	private\r\n" + "2.	package-private\r\n" + "3.	public\r\n" + "4.	protected", "3", 1);
		Question quest12Theme3 = new Question(
				"Какое ключевое слово неявно присутствует в объявление методов интерфейса?",
				"1.	static\r\n" + "2.	abstract\r\n" + "3.	final\r\n" + "4.	protected", "2", 1);
		Question quest13Theme3 = new Question(
				"Какое ключевое слово используется для указания, что класс реализует интерфейс?",
				"1.	realize\r\n" + "2.	extends\r\n" + "3.	implements\r\n" + "4.	instanceof\r\n" + "", "3", 1);
		Question quest14Theme3 = new Question("Укажите только верные утверждения.",
				"1.	Класс может наследоваться только от одного класса..\r\n"
						+ "2.	Класс может реализовать несколько интерфейсов.\r\n"
						+ "3.	Интерфейс может наследоваться от класса\r\n"
						+ "4.	Абстрактный класс может наследоваться от интерфейса\r\n"
						+ "5.	Интерфейс может быть унаследован (расширен)  другим интерфейсом.\r\n"
						+ "6.	Класс может наследовать интерфейс\r\n"
						+ "7.	Класс может наследоваться от одного класса и одновременно реализовывать несколько интерфейсов.",
				"1" + "2" + "5" + "7", 4);
		Question quest15Theme3 = new Question(
				"Каким образом можно запретить наследование класса (речь идет о не вложенных классах) ?",
				"1.	Добавить модификатор abstract\r\n" + "2.	Добавить модификатор final\r\n"
						+ "3.	Добавить модификатор private\r\n" + "4.	Не определять конструктор\r\n"
						+ "5.	Объявить все конструкторы класса c спецификатором доступа private\r\n"
						+ "6.	Запретить наследование нельзя",
				"1", 1);
		Question quest16Theme3 = new Question("Можно ли объявить конструктор в интерфейсе?",
				"1.	Да\r\n" + "2.	Нет\r\n" + "3.	Да,  но только если сделать конструктор абстрактным.", "2", 1);
		Question quest17Theme3 = new Question("Можно ли наследоваться от класса java.lang.String?",
				"1.	Да\r\n" + "2.	Нет\r\n" + "3.	Не в курсе", "2", 1);
		Question quest18Theme3 = new Question(
				"Какие модификаторы позволяют обращаться к полю/методу публичного класса верхнего уровня из других классов верхнего уровня, находящихся в том же пакете?",
				"1.	по умолчанию (package-private)\r\n" + "2.	protected\r\n" + "3.	public\r\n" + "4.	private",
				"1" + "2" + "3", 3);
		Question quest19Theme3 = new Question(
				"Можно ли переопределяя метод изменить его модификатор доступа с \"package-private\" на \"protected\"?",
				"1.	Да\r\n" + "2.	Нет\r\n" + "3.	Не в курсе", "2", 1);
		Question quest20Theme3 = new Question("Какие из следующих утверждений истинные?",
				"1.	Абстрактный метод не может быть статическим\r\n"
						+ "2.	Не статический метод не может быть вызван из статического без указания экземпляра класса\r\n"
						+ "3.	Статический метод не может быть вызван из не статического метода\r\n"
						+ "4.	private метод не может быть вызван из другого метода этого класса\r\n"
						+ "5.	final метод не может быть статическим",
				"1" + "3", 2);
		Question quest21Theme3 = new Question("Что такое this в java.",
				"1.	Неявная ссылка в не статическом методе на объект класса для которого был вызван метод.\r\n"
						+ "2.	Неявная ссылка в  методе на объект класса который вызвал  метод.\r\n"
						+ "3.	Явная ссылка на переменную экземпляра\r\n" + "4.	Название переменной класса",
				"1", 1);
		Question quest22Theme3 = new Question("В каких случаях в классе присутствует конструктор по умолчанию?",
				"1.	Если в классе не объявлены конструкторы.\r\n"
						+ "2.	Если конструктор по умолчанию явно объявлен в классе.\r\n"
						+ "3.	Всегда присутствует.\r\n" + "4.	Только если явно объявлен в классе.",
				"1", 1);
		Question quest23Theme3 = new Question("Для чего применяется оператор instanceof?",
				"1.	Чтобы проверить, соответствует ли текущее значение переменной указанному типу,\r\n"
						+ "2.	Чтобы проверить инстанцирован ли объект в переменной.\r\n"
						+ "3.	Чтобы определить тип переменной",
				"3", 1);

		Question[] questionsTheme1 = { quest1Theme1, quest2Theme1, quest3Theme1, quest4Theme1, quest5Theme1,
				quest6Theme1, quest7Theme1, quest8Theme1 };
		Question[] questionsTheme2 = { quest1Theme2, quest2Theme2, quest3Theme2, quest4Theme2, quest5Theme2,
				quest6Theme2, quest7Theme2, quest8Theme2, quest9Theme2, quest10Theme2, quest11Theme2, quest12Theme2,
				quest13Theme2, quest14Theme2, quest15Theme2, quest16Theme2, quest17Theme2, quest18Theme2, quest19Theme2,
				quest20Theme2, quest21Theme2, quest22Theme2, quest23Theme2, quest24Theme2, quest25Theme2,
				quest26Theme2 };
		Question[] questionsTheme3 = { quest1Theme3, quest2Theme3, quest3Theme3, quest4Theme3, quest5Theme3,
				quest6Theme3, quest7Theme3, quest8Theme3, quest9Theme3, quest10Theme3, quest11Theme3, quest12Theme3,
				quest13Theme3, quest14Theme3, quest15Theme3, quest16Theme3, quest17Theme3, quest18Theme3, quest19Theme3,
				quest20Theme3, quest21Theme3, quest22Theme3, quest23Theme3 };

		Test testTheme1 = new Test(questionsTheme1);
		Test testTheme2 = new Test(questionsTheme2);
		Test testTheme3 = new Test(questionsTheme3);

		Test[] tests = { testTheme1, testTheme2, testTheme3 };
		return tests;

	}

	private static void genarateControllers() {

	}

	private static void generateGUI() {
		MainFrame mainFrame = new MainFrame();
		mainFrame.setVisible(true);
	}

}
